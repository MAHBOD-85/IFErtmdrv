---
IFEware realtime NES music driver documentation
---

1. Introduction

This audio driver is meant for games with extremely low rom sizes and designed to be very modular allowing for addition or removal of features with ease and can integrate with any program's logic as easily as pasting in the code in
soundeffects have to be handled externally but a temporary mute counter is provided for such purposes 
there is no support for hardware envelope, length counter and hardware sweep but there is support for triangle linear counter trick
this driver operates in $710 to $76F region of the work ram by default and requires 5 zeropage bytes

---

2. Files

the driver operates on 5 file types

freqtbl.db (256 bytes)
instrument.db (256 bytes)
instrument2.db (256 bytes)
songX.db (arbitrary count, 256 bytes)
patterndataX.db (arbitrary count, size is multiples of 256 bytes but a limit of 3072 is advised)
dpcmX.dmc (3 are allowed)
dpcmtbl.db (16 bytes, can reside at the end of freqtbl)

all files should be aligned to pages but you can merge them with eachother

---

3. freqtbl.db

this table stores register patterns in little endian mode to be in line with the APU, A1 to C8 and noise values are stored by default but the user can add custom tables
ALL VALUES SETTING THE NOTE IN A RELATIVE OR ABSOLUTE MANNER MUST BE EVEN, values $A0 and above are considered to be blacklisted from any transposation and finetuning by default but not relative arpeggio, values $F0 and above are relatively unused for the effects take their place

---

4. instrument.db & instrument2.db

all channels share these databases for instruments and go thru each byte one tick at a time

these databases work in pairs with the first file containing $4000,4x patterns (note: for triangle length counter only obeys the low nibble so triangle growl trick can be done with ease while it opens up for sharing instruments between pulse and triangle) and the second file being a pitch modifier, the pitch modifier works in this pattern: if the value is even do relative arpeggio and if the value is odd do relative finetune, (00 and 01 do no changes, 02 and 03 pitch and finetune up by 1 step, FE and FF do the same but downwards)

$C0 is a jump flag and the corresponding byte in the second file tells it where to jump

$D0 is a delay flag which reads from the corresponsing byte at the second file and indexes the speedtable and if the result is $FF it means stop instrument

$E0 means don't change the $4000,4x register pattern and only do pitch changes

---

5. songX.db

orders are laid out in bunches of four and consist of pulse 1, pulse 2, triangle and noise/DPCM, they are formatted in $XY and index the pattern data in $0YX0 offset from song begin (but nothing is stopping you from using songX.db as pattern data)

$00 is a NOP

$10 $XX $YY
this is header information and always should come first, it can also be applied mid song and always applies itself to the next pattern
$XX sets pattern length to a zero based value
$YY points to an address in speedtbl.db to pull 4 values from

$20 $XX $YY sets the orders position to the little endian value specified by the next bytes $YY can be zero to signify no change to the high byte 

---

6. patterndataX.db

effects and notes are processed in this order: 

$F9 $XX $YY
is a miniloop effect and consists of 3 bytes, it checks the channel's miniloop flag against the second byte and if it's less or equal, it will jump to a position in the page defined by the third byte and increments the channel's miniloop flag. and if it's more than the second byte it will pass thru and the miniloop flag will be reset to zero

$F8 $XX
sets miniloop flag to the second byte

$FC $XX
sets retained mode instrument to second byte, if the byte is $FF the channel goes into immediate instrument mode

$FD $XX
sets retained mode instrument for odd notes to second byte, no immediate mode for this one

$FB $XX
transposes a note by a value defined by the second byte (must be even)

$FA $XX
sets base finetune to the second byte (must be even)

$F4 $XX
sets pattern speed divisor to the second byte

$FF $XX 
jumps into a position in the current page defined by the next byte

note goes here, if the instruments are in immediate mode instrument follows next, if it's $FE it's cosidered a NOP and there is no need to follow with instrument in immediate mode and if the note is an odd number it is rounded down and the secondary instrument is used

$FX $YY
this is a sequence break effect and values for X are 0 to 3 which offset the channel's position in the groove speeds and the next byte sets the channel's frame counter to next byte to an arbitrary address in speedtbl.db

---

7. speedtbl.db
it contains values referenced by song header bunch and delay commands in orders and instruments, if the region is PAL an $80 offset is applied

---

8. dpcmtbl.db

this table stores 3 $4010 to $4013 register patterns in groups of 4, first 4 bytes are reserved
the DPCM playback is determined by noise channel's instrument, if it is $00 to $3F no DPCM will play, if it's $40 to $7F the first DPCM will play and vice versa

---

9. special modes

9.1 temporary mute counter
this counter suspends buffer writes of a specific channel for X amount of frames

9.2 finetune
this adds or subtracts values from the low byte of a channel's note, BE CAREFUL that this will not account for risky notes in 2A03 APU and will wrap around the register

9.3 region
the Region variable is where you set the region for the driver before you initialize it, 0 is NTSC, 1 is PAL and 2 is Dendy

10. version Z
this version has 5 patterns per order and the z-saw channel is controlled by %XXYYYYYY of what is normally a $4000,4x pattern with %XX being timber and %YYYYYY being volume
